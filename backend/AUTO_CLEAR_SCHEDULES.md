# 시간표 자동생성 시 기존 일정 자동 삭제 기능

## 개요
시간표 자동생성 시 기존의 자동생성된 일정을 모두 삭제하고 새로 배정하도록 개선되었습니다.

## 변경 사항

### 기존 동작
```
시간표 자동생성 버튼 클릭
  ↓
기존 일정 유지
  ↓
새로운 일정 추가 시도
  ↓
시간 충돌 발생 → 배정 실패
```

**문제점:**
- 기존 자동생성 일정이 남아있어 시간 충돌 발생
- 사용자가 수동으로 기존 일정을 삭제해야 함
- 재생성 시 혼란 발생

### 새로운 동작
```
시간표 자동생성 버튼 클릭
  ↓
기존 자동생성 일정 자동 삭제 (선배정은 유지)
  ↓
깨끗한 상태에서 새로운 일정 생성
  ↓
배정 성공 ✓
```

**개선점:**
- 자동으로 기존 일정 삭제
- 선배정(is_pre_assigned=true)은 유지
- 항상 깨끗한 상태에서 재생성

## 구현 내용

### ScheduleGenerator.generateSchedule() 수정

```typescript
async generateSchedule(startDate: string): Promise<ScheduleGenerationResult> {
  try {
    // 1. 기존 자동생성 일정 삭제 (선배정은 유지)
    console.log('기존 자동생성 일정 삭제 중...');
    await this.clearAutoGeneratedSchedules();
    console.log('기존 자동생성 일정 삭제 완료');

    // 2. 선배정=2인 교과목을 excel_order 순으로 정렬
    const coursesToAssign = await this.courseRepo.findByPreAssignment(2);
    
    // ... 나머지 로직
  }
}
```

### clearAutoGeneratedSchedules() 메서드

```typescript
/**
 * 자동 생성된 일정을 모두 삭제합니다 (선배정은 유지)
 */
async clearAutoGeneratedSchedules(): Promise<void> {
  const allSchedules = await this.scheduleRepo.findAll();
  
  for (const schedule of allSchedules) {
    if (!schedule.is_pre_assigned) {
      await this.scheduleRepo.delete(schedule.id);
    }
  }
}
```

## 삭제 기준

### 삭제되는 일정
- `is_pre_assigned = false` (자동생성 일정)
- 이전 자동생성으로 만들어진 모든 일정
- 시험 일정 포함 (`is_exam = true`이지만 `is_pre_assigned = false`)

### 유지되는 일정
- `is_pre_assigned = true` (선배정 일정)
- 사용자가 수동으로 배정한 일정
- 선배정 페이지에서 등록한 일정

## 실행 순서

```
1. 기존 자동생성 일정 삭제
   ├─ 모든 일정 조회
   ├─ is_pre_assigned = false인 일정 필터링
   └─ 해당 일정 삭제

2. ConstraintValidator 초기화
   └─ TimeSlot 맵 생성

3. 선배정 일정 TimeSlot에 반영
   └─ 선배정 일정은 삭제되지 않았으므로 정상 반영

4. 교과목 자동 배정
   ├─ 선배정=2인 교과목 조회
   ├─ 각 교과목 순차 배정
   └─ 데이터베이스에 저장

5. 결과 반환
```

## 로그 출력

시간표 자동생성 시 다음과 같은 로그가 출력됩니다:

```
기존 자동생성 일정 삭제 중...
기존 자동생성 일정 삭제 완료

교과목 배정 시작: 네트워크 보안 (시수: 6, 평가: 1)
교과목 배정 완료: 네트워크 보안 - 일반 일정 2개, 시험 일정 1개

교과목 배정 시작: 데이터베이스 (시수: 3, 평가: 0)
교과목 배정 완료: 데이터베이스 - 일반 일정 1개, 시험 일정 0개

시간표 생성 완료: 총 4개의 일정 생성
성공: 2개, 실패: 0개
```

## 사용 시나리오

### 시나리오 1: 첫 번째 자동생성
```
상태: 선배정 일정 3개 존재
실행: 시간표 자동생성
결과:
  - 선배정 일정 3개 유지
  - 자동생성 일정 10개 추가
  - 총 13개 일정
```

### 시나리오 2: 두 번째 자동생성 (재생성)
```
상태: 선배정 일정 3개 + 자동생성 일정 10개
실행: 시간표 자동생성
결과:
  - 기존 자동생성 일정 10개 삭제
  - 선배정 일정 3개 유지
  - 새로운 자동생성 일정 12개 추가
  - 총 15개 일정
```

### 시나리오 3: 선배정 추가 후 재생성
```
상태: 선배정 일정 3개 + 자동생성 일정 10개
작업: 선배정 2개 추가 (총 5개)
실행: 시간표 자동생성
결과:
  - 기존 자동생성 일정 10개 삭제
  - 선배정 일정 5개 유지
  - 새로운 자동생성 일정 8개 추가 (선배정 고려)
  - 총 13개 일정
```

## 장점

### 1. 사용자 편의성
- 수동 삭제 불필요
- 재생성 시 혼란 없음
- 항상 최신 상태 유지

### 2. 데이터 일관성
- 중복 일정 방지
- 시간 충돌 방지
- 깨끗한 상태에서 시작

### 3. 선배정 보호
- 사용자가 수동으로 배정한 일정 유지
- 선배정 일정은 자동생성에 반영
- 의도하지 않은 삭제 방지

## 주의사항

1. **선배정 확인**: 자동생성 전에 선배정이 올바른지 확인하세요.

2. **되돌리기 불가**: 삭제된 자동생성 일정은 복구할 수 없습니다.

3. **실행 시간**: 기존 일정이 많을 경우 삭제에 시간이 걸릴 수 있습니다.

4. **동시 실행**: 여러 사용자가 동시에 자동생성을 실행하면 문제가 발생할 수 있습니다.

## 관련 파일

- `backend/src/services/ScheduleGenerator.ts`
  - `generateSchedule()` 메서드 수정
  - `clearAutoGeneratedSchedules()` 메서드 사용

- `backend/src/repositories/ScheduleRepository.ts`
  - `findAll()` 메서드
  - `delete()` 메서드

## 결론

이제 시간표 자동생성 시 기존의 자동생성 일정이 자동으로 삭제되어, 항상 깨끗한 상태에서 새로운 시간표를 생성할 수 있습니다. 선배정 일정은 유지되므로 사용자가 수동으로 배정한 일정은 안전하게 보호됩니다.
