import { CourseRepository } from '../repositories/CourseRepository';
import { InstructorRepository } from '../repositories/InstructorRepository';
import { ScheduleRepository } from '../repositories/ScheduleRepository';
import { OffDayRepository } from '../repositories/OffDayRepository';
import { SchoolHolidayRepository } from '../repositories/SchoolHolidayRepository';
import { ConstraintValidator } from './ConstraintValidator';
import { CourseAssigner } from './CourseAssigner';
import { addDays } from '../utils/scheduleUtils';

/**
 * 시간표 자동 생성 결과
 */
export interface ScheduleGenerationResult {
  success: boolean;
  message: string;
  scheduleCount: number;
  errors?: string[];
}

/**
 * 시간표 자동 생성 서비스
 */
export class ScheduleGenerator {
  private courseRepo: CourseRepository;
  private instructorRepo: InstructorRepository;
  private scheduleRepo: ScheduleRepository;
  private offDayRepo: OffDayRepository;
  private holidayRepo: SchoolHolidayRepository;

  constructor(
    courseRepo: CourseRepository,
    instructorRepo: InstructorRepository,
    scheduleRepo: ScheduleRepository,
    offDayRepo: OffDayRepository,
    holidayRepo?: SchoolHolidayRepository
  ) {
    this.courseRepo = courseRepo;
    this.instructorRepo = instructorRepo;
    this.scheduleRepo = scheduleRepo;
    this.offDayRepo = offDayRepo;
    this.holidayRepo = holidayRepo || new SchoolHolidayRepository();
  }

  /**
   * 시간표를 자동으로 생성합니다
   * @param startDate 시작 날짜 (YYYY-MM-DD)
   * @returns 생성 결과
   */
  async generateSchedule(startDate: string): Promise<ScheduleGenerationResult> {
    try {
      // 1. 기존 자동생성 일정 삭제 (선배정은 유지)
      console.log('기존 자동생성 일정 삭제 중...');
      await this.clearAutoGeneratedSchedules();
      console.log('기존 자동생성 일정 삭제 완료');

      // 2. 선배정=2인 교과목을 excel_order 순으로 정렬
      const coursesToAssign = await this.courseRepo.findByPreAssignment(2);

      if (coursesToAssign.length === 0) {
        return {
          success: true,
          message: '배정할 교과목이 없습니다.',
          scheduleCount: 0
        };
      }

      // 3. ConstraintValidator 초기화
      const validator = new ConstraintValidator(this.scheduleRepo, this.offDayRepo);
      
      // 충분한 기간의 TimeSlot 생성 (최대 1년)
      validator.initializeTimeSlots(startDate, 365);

      // 4. 선배정된 일정을 TimeSlot 배열에 반영
      const endDate = addDays(startDate, 365);
      await validator.markPreAssignedSlots(startDate, endDate);

      // 5. CourseAssigner 초기화
      const assigner = new CourseAssigner(
        this.courseRepo,
        this.instructorRepo,
        validator
      );

      // 6. 각 교과목을 순차적으로 배정하는 메인 루프
      let totalScheduleCount = 0;
      const errors: string[] = [];

      for (const course of coursesToAssign) {
        try {
          console.log(`교과목 배정 시작: ${course.과목} (시수: ${course.시수}, 평가: ${course.평가})`);
          const assignments = await assigner.assignCourse(course, startDate);

          // 7. 생성된 일정을 데이터베이스에 저장
          let regularCount = 0;
          let examCount = 0;
          
          for (const assignment of assignments) {
            await this.scheduleRepo.create({
              course_id: assignment.courseId,
              instructor_id: assignment.instructorId,
              date: assignment.date,
              start_period: assignment.startPeriod,
              end_period: assignment.endPeriod,
              is_pre_assigned: false,
              is_exam: assignment.isExam || false
            });
            
            if (assignment.isExam) {
              examCount++;
            } else {
              regularCount++;
            }
            totalScheduleCount++;
          }
          
          console.log(
            `교과목 배정 완료: ${course.과목} - ` +
            `일반 일정 ${regularCount}개, 시험 일정 ${examCount}개`
          );
        } catch (error) {
          // 배정 불가능한 경우 에러 수집
          const errorMessage = error instanceof Error ? error.message : String(error);
          const detailedError = `교과목 "${course.과목}" (ID: ${course.id}, 시수: ${course.시수}): ${errorMessage}`;
          errors.push(detailedError);
          console.error(`교과목 배정 실패: ${course.과목}`, error);
        }
      }

      // 8. 결과 반환
      console.log(`\n시간표 생성 완료: 총 ${totalScheduleCount}개의 일정 생성`);
      console.log(`성공: ${coursesToAssign.length - errors.length}개, 실패: ${errors.length}개`);
      
      if (errors.length > 0) {
        console.error('\n배정 실패 목록:');
        errors.forEach((error, index) => {
          console.error(`  ${index + 1}. ${error}`);
        });
        
        return {
          success: false,
          message: `일부 교과목을 배정할 수 없습니다. 총 ${totalScheduleCount}개의 일정이 생성되었습니다.`,
          scheduleCount: totalScheduleCount,
          errors
        };
      }

      return {
        success: true,
        message: `시간표가 성공적으로 생성되었습니다. 총 ${totalScheduleCount}개의 일정이 생성되었습니다.`,
        scheduleCount: totalScheduleCount
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error('시간표 생성 중 오류 발생:', error);
      
      return {
        success: false,
        message: `시간표 생성 중 오류가 발생했습니다: ${errorMessage}`,
        scheduleCount: 0,
        errors: [errorMessage]
      };
    }
  }

  /**
   * 자동 생성된 일정을 모두 삭제합니다 (선배정은 유지)
   */
  async clearAutoGeneratedSchedules(): Promise<void> {
    const allSchedules = await this.scheduleRepo.findAll();
    
    for (const schedule of allSchedules) {
      if (!schedule.is_pre_assigned) {
        await this.scheduleRepo.delete(schedule.id);
      }
    }
  }
}
